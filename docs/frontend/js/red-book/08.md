---
title: 红宝书
prev:
  text: 迭代器与生成器
  link: ./07.md

next:
  text: 对象、类与面向对象编程
  link: ./08.md
---

## 对象、类与面向对象编程

ECMA-262 将对象定义为一组属性的无序集合

### 理解对象

#### 属性的类型

ECMA-262 使用一些内部特性来描述属性的特征，属性分为两种：数据属性和访问器属性

**1. 数据属性**

数据属性包含一个保存数据值的位置，在这个位置可以读取和写入值。数据属性有 4 个特性描述它的行为：

- [[Configurable]]：默认为 true。表示是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性
- [[Enumerable]]：默认为 true。表示属性是否可以通过 for-in 循环返回
- [[Writable]]：默认为 true。表示属性的值是否可以被修改
- [[value]]: 默认为 undefined。包含属性实际的值，即前面提到的那个读取和写入属性值的位置

Object.definedProperty() 修改属性的默认特性，如果不指定 configurable / enumerable / writable，则默认为 false：

```js
let person = {}
Object.defineProperty(person, 'name', {
	writable: false,
	value: 'Nicholas',
})
```

**2. 访问器属性**

访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。访问器属性有 4 个特性描述它的行为：

- [[Configurable]]：默认为 true。表示是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性‘
- [[Enumerable]]：默认为 true。表示属性是否可以通过 for-in 循环返回
- [[Get]]：默认为 undefined。获取函数，在读取属性时调用
- [[Set]]：默认为 undefined。设置函数，在写入属性时调用

访问器属性是不能直接定义的，必须使用 Object.definedProperty()：

```js
let book = {
	year_: 2004, // 下划线表示该属性并不希望在对象外部被访问
	edition: 1,
}

Object.defineProperty(book, 'year', {
	get() {
		return this.year_
	},
	set(newValue) {
		if (newValue > 2004) {
			this.year_ = newValue
			this.edition += newValue - 2004
		}
	},
})

book.year = 2005
console.log(book.edition) // 2
```

#### 定义多个属性

Object.defineProperties() 可以通过多个描述符一次定义多个属性，如果数据属性不指定 configurable / enumerable / writable，则默认为 false

#### 读取属性的特性

Object.getOwnPropertyDescriptor() 可以取得给定属性的描述符

ECMAScript 2017 新增了 Object.getOwnPropertyDescriptors() 静态方法，可以取得给定对象所有自有属性的描述符

#### 合并对象

Object.assign() 可以把任意多个源对象可枚举的自有属性浅拷贝到目标对象，然后返回目标对象。对每个符合条件的属性，这个方法会使用源对象上的 [[Get]] 取得属性值，然后使用目标对象上的 [[Set]] 设置属性值

```js
const dest = {
	set a(val) {
		console.log(`Invoked dest setter with param ${val}`)
	},
}

const src = {
	get a() {
		console.log('Invoked src getter')
		return 'foo'
	},
}

Object.assign(dest, src)
// Invoked src getter
// Invoked dest setter with param foo
console.log(dest)
```

- 如果多个源对象有相同的属性，则使用最后一个复制的值
- 从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象，即不能在两个对象间转移获取函数和设置函数
- 如果赋值期间出错，则操作会中止并退出，同时抛出错误。因此 Object.assign() 是一个尽力而为、可能只会完成部分复制的方法

#### 对象标识及相等判定

Object.is() 用于比较两个值是否相等，与 === 的行为基本一致，但是它对 NaN 和 +0/-0 作了特殊处理

要检查超过两个值，递归地利用相等性传递即可：

```js
function recursivelyCheckEqual(x, ...rest) {
	return Object.is(x, rest[0]) && (rest.length < 2 || recursivelyCheckEqual(...rest))
}
```

#### 增强的对象语法

ECMAScript 6 为定义和操作对象新增了很多及其有用的语法糖特性：

- 属性值简写
- 可计算属性
- 简写方法名

#### 对象解构

对象解构就是使用与对象匹配的结构来实现对象属性赋值

如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中，否则会被当成一个代码块：

```js
let personName, personAge
let person = {
	name: 'Nicholas',
	age: 29,
}
;({ name: personName, age: personAge } = person)
```

- 嵌套解构
- 部分解构：需要注意的是，涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分
- 参数上下文匹配：在函数参数列表中也可以进行解构赋值

### 创建对象
