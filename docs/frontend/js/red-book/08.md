---
title: 红宝书
prev:
  text: 迭代器与生成器
  link: ./07.md

next:
  text: 对象、类与面向对象编程
  link: ./08.md
---

## 对象、类与面向对象编程

ECMA-262 将对象定义为一组属性的无序集合

### 理解对象

#### 属性的类型

ECMA-262 使用一些内部特性来描述属性的特征，属性分为两种：数据属性和访问器属性

**1. 数据属性**

数据属性包含一个保存数据值的位置，在这个位置可以读取和写入值。数据属性有 4 个特性描述它的行为：

- [[Configurable]]：默认为 true。表示是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性
- [[Enumerable]]：默认为 true。表示属性是否可以通过 for-in 循环返回
- [[Writable]]：默认为 true。表示属性的值是否可以被修改
- [[value]]: 默认为 undefined。包含属性实际的值，即前面提到的那个读取和写入属性值的位置

Object.defineProperty() 修改属性的默认特性，如果不指定 configurable / enumerable / writable，则默认为 false：

```js
let person = {}
Object.defineProperty(person, 'name', {
	writable: false,
	value: 'Nicholas',
})
```

**2. 访问器属性**

访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。访问器属性有 4 个特性描述它的行为：

- [[Configurable]]：默认为 true。表示是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性‘
- [[Enumerable]]：默认为 true。表示属性是否可以通过 for-in 循环返回
- [[Get]]：默认为 undefined。获取函数，在读取属性时调用
- [[Set]]：默认为 undefined。设置函数，在写入属性时调用

访问器属性是不能直接定义的，必须使用 Object.definedProperty()：

```js
let book = {
	year_: 2004, // 下划线表示该属性并不希望在对象外部被访问
	edition: 1,
}

Object.defineProperty(book, 'year', {
	get() {
		return this.year_
	},
	set(newValue) {
		if (newValue > 2004) {
			this.year_ = newValue
			this.edition += newValue - 2004
		}
	},
})

book.year = 2005
console.log(book.edition) // 2
```

#### 定义多个属性

Object.defineProperties() 可以通过多个描述符一次定义多个属性，如果数据属性不指定 configurable / enumerable / writable，则默认为 false

#### 读取属性的特性

Object.getOwnPropertyDescriptor() 可以取得给定属性的描述符

ECMAScript 2017 新增了 Object.getOwnPropertyDescriptors() 静态方法，可以取得给定对象所有自有属性的描述符

#### 合并对象

Object.assign() 可以把任意多个源对象可枚举的自有属性浅拷贝到目标对象，然后返回目标对象。对每个符合条件的属性，这个方法会使用源对象上的 [[Get]] 取得属性值，然后使用目标对象上的 [[Set]] 设置属性值

```js
const dest = {
	set a(val) {
		console.log(`Invoked dest setter with param ${val}`)
	},
}

const src = {
	get a() {
		console.log('Invoked src getter')
		return 'foo'
	},
}

Object.assign(dest, src)
// Invoked src getter
// Invoked dest setter with param foo
console.log(dest)
```

- 如果多个源对象有相同的属性，则使用最后一个复制的值
- 从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象，即不能在两个对象间转移获取函数和设置函数
- 如果赋值期间出错，则操作会中止并退出，同时抛出错误。因此 Object.assign() 是一个尽力而为、可能只会完成部分复制的方法

#### 对象标识及相等判定

Object.is() 用于比较两个值是否相等，与 === 的行为基本一致，但是它对 NaN 和 +0/-0 作了特殊处理

要检查超过两个值，递归地利用相等性传递即可：

```js
function recursivelyCheckEqual(x, ...rest) {
	return Object.is(x, rest[0]) && (rest.length < 2 || recursivelyCheckEqual(...rest))
}
```

#### 增强的对象语法

ECMAScript 6 为定义和操作对象新增了很多及其有用的语法糖特性：

- 属性值简写
- 可计算属性
- 简写方法名

#### 对象解构

对象解构就是使用与对象匹配的结构来实现对象属性赋值

如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中，否则会被当成一个代码块：

```js
let personName, personAge
let person = {
	name: 'Nicholas',
	age: 29,
}
;({ name: personName, age: personAge } = person)
```

- 嵌套解构
- 部分解构：需要注意的是，涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分
- 参数上下文匹配：在函数参数列表中也可以进行解构赋值

### 创建对象

使用 Object 构造函数和对象字面量可以方便的创建对象，但是这种方式有个缺点：创建具有同样接口的多个对象需要重复编写很多代码

#### 工厂模式

工厂模式用于抽象创建特定对象的过程

下面的例子展示了一种按照特定接口创建对象的方式：

```js
function createPerson(name, age, job) {
	let o = new Object()
	o.name = name
	o.age = age
	o.job = job
	o.sayName = function () {
		console.log(this.name)
	}
	return o
}

let person1 = createPerson('Nicholas', 29, 'Software Engineer')
let person2 = createPerson('Greg', 27, 'Doctor')
```

> 这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）

#### 构造函数模式

ECMAScript 中的构造函数就是用于创建特定类型对象的

构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式也可以

使用 new 操作符调用构造函数会执行如下操作：

- 在内存中创建一个新对象
- 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数的 prototype 属性
- this 指向新对象
- 执行构造函数内部的代码
- 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象

`instanceof` 操作符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

> 构造函数的问题在于其定义的方法会在每个实例上都创建一遍

#### 原型模式

每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法

```js
function Person() {}

Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
	console.log(this.name)
}

let person1 = new Person()
person1.sayName() // Nicholas

let person2 = new Person()
person2.sayName() // Nicholas

console.log(person1.sayName === person2.sayName) // true
```

与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的

**1. 理解原型**

构造函数.prototype 指向原型对象，原型对象.constructor 指向构造函数，实例对象.\_\_proto\_\_ 指向原型对象

`isPrototypeOf()` 方法用于检测当前对象是否是传入对象的原型

`Object.getPrototypeOf()` 方法返回传入对象的原型

~~`Object.setPrototypeOf()` 方法用于设置传入对象的原型，但其可能会严重影响性能，因为其涉及所有访问了那些修改过 [[Prototype]] 的对象的代码~~

`Object.create()` 方法创建一个新对象，将参数作为新创建的对象的\_\_proto\_\_

**2. 原型层级**

`hasOwnProperty()` 方法用于确定某个属性实在实例上还是在原型对象上，继承自 Object

`Object.getOwnPropertyDescriptor()` 方法也只对实例有效

**3. 原型和 in 操作符**

有两张方式使用 in 操作符：

- 单独使用，会在可以通过对象访问指定属性时返回 true，无论该属性存在于实例还是原型中
- 在 for-in 循环中使用

单独使用 in 结合 'hasOwnProperty()' 方法可以确定属性是否存在于原型上：

```js
function hasPrototypeProperty(object, name) {
	return !object.hasOwnProperty(name) && name in object
}
```

在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回

`Object.keys()` 方法返回对象上所有可枚举的**实例属性**

`Object.getOwnPropertyNames()` 方法返回对象上所有**实例属性**，无论是否可枚举

`Object.getOwnPropertySymbols()` 方法同上，但是只针对符号

**4. 属性枚举顺序**

- for-in 和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异
- Object.getOwnPropertyNames() / Object.getOwnPropertySymbols() / Object.assign() 的枚举顺序是确定的，先以升序枚举数值键，然后以插入顺序枚举字符串和符号键，在对象字面量中定义的键以它们逗号分隔的顺序插入

```js
const k1 = Symbol('k1')
const k2 = Symbol('k2')

let o = {
	1: 1,
	first: 'first',
	[k2]: 'k2',
	second: 'second',
	0: 0,
}

o[k1] = 'k1'
o[3] = 3
o.third = 'third'
o[2] = 2

console.log(Object.getOwnPropertyNames(o)) // ['0', '1', '2', '3', 'first', 'second', 'third']
console.log(Object.getOwnPropertySymbols(o)) // [Symbol(k2), Symbol(k1)]
```

#### 对象迭代

`Object.values() / Object.entires`：非字符串属性会被转换为字符串输出，且执行对象的浅复制，符号属性会被忽略

**1. 其他原型语法**

```js
function Person() {}

Person.prototype = {
	name: 'Nicholas',
	age: 29,
	job: 'Software Engineer',
	sayName() {
		console.log(this.name)
	},
}

// 恢复 constructor 属性
Object.defineProperty(Person.prototype, 'constructor', {
	enumerable: false,
	value: Person,
})
```

**2. 原生对象原型**

不推荐在产品环境中修改原生对象原型，而是创建一个自定义类继承原生类型

**3. 原型的问题**

最主要的问题源自它的共享特性，针对包含引用值的属性，会导致实例间相互影响，故通常不单独使用原型模式

### 继承
